import numpy as np


def sharpen_image(cell_value, white):
    if white > 240:
        threshold = 225
    else:
        threshold = 70

    if cell_value < threshold : 
        return 0
    else:
        return 250

def normalize_image(cell_value):
    if cell_value < 70 : 
        return 0
    else:
        return 250


def trim_outer_edge(whole_image):
    threshold = 100
    bar_height = len(whole_image[:,1])/15

    # compute the averages along the edges
    # produce list of the form (avg, index)
    left1 = [(whole_image[:bar_height, x].mean(),x) 
             for x in range(len(whole_image[1,:])/15)]
    left2 = [(whole_image[-bar_height:, x].mean(),x) 
             for x in range(len(whole_image[1,:])/15)]

    right1 = [(whole_image[:bar_height, -x-1].mean(),-x-1) 
              for x in range(len(whole_image[1,:])/15)]
    right2 = [(whole_image[-bar_height:, -x-1].mean(),-x-1) 
              for x in range(len(whole_image[1,:])/15)]

    top1 = [(whole_image[x, :bar_height].mean(),x) 
            for x in range(len(whole_image[1,:])/15)]
    top2 = [(whole_image[x, -bar_height:].mean(),x) 
            for x in range(len(whole_image[1,:])/15)]

    bottom1 = [(whole_image[-x-1, :bar_height].mean(),-x-1) 
               for x in range(len(whole_image[1,:])/15)]
    bottom2 = [(whole_image[-x-1, -bar_height:].mean(),-x-1) 
               for x in range(len(whole_image[1,:])/15)]


    # reduce the list to the minimal values (darkest cells)
    left1 = [(x,i) for (x,i) in left1 if x < min(left1)[0]+10]
    left2 = [(x,i) for (x,i) in left2 if x < min(left2)[0]+10]

    right1 = [(x,i) for (x,i) in right1 if x < min(right1)[0]+10]
    right2 = [(x,i) for (x,i) in right2 if x < min(right2)[0]+10]

    top1 = [(x,i) for (x,i) in top1 if x < min(top1)[0]+10]
    top2 = [(x,i) for (x,i) in top2 if x < min(top2)[0]+10]

    bottom1 = [(x,i) for (x,i) in bottom1 if x < min(bottom1)[0]+10]
    bottom2 = [(x,i) for (x,i) in bottom2 if x < min(bottom2)[0]+10]
    

    # sort the tuples by index, keeping only the index
    left1 = sorted(left1, key = lambda x:x[1])
    left2 = sorted(left2, key = lambda x:x[1])
    right1 = sorted(right1, key = lambda x:x[1])
    right2 = sorted(right2, key = lambda x:x[1])
    top1 = sorted(top1, key = lambda x:x[1])
    top2 = sorted(top2, key = lambda x:x[1])
    bottom1 = sorted(bottom1, key = lambda x:x[1])
    bottom2 = sorted(bottom2, key = lambda x:x[1])

    
    # average the indeces
    left_edge = (left1[len(left1)/2][1] + left2[len(left2)/2][1])/2
    right_edge = (right1[len(right1)/2][1] + right2[len(right2)/2][1])/2
    top_edge = (top1[len(top1)/2][1] + top2[len(top2)/2][1])/2
    bottom_edge = (bottom1[len(bottom1)/2][1] + bottom2[len(bottom2)/2][1])/2
    
    return whole_image[top_edge:bottom_edge, left_edge:right_edge]





def edge_info(whole_image):
    threshold = 100
    bar_height = len(whole_image[:,1])/10

    # compute the averages along the edges
    # produce list of the form (avg, index)
    left1 = [(whole_image[:bar_height, x].mean(),x) 
             for x in range(len(whole_image[1,:])/15)]
    left2 = [(whole_image[-bar_height:, x].mean(),x) 
             for x in range(len(whole_image[1,:])/15)]

    right1 = [(whole_image[:bar_height, -x-1].mean(),-x-1) 
              for x in range(len(whole_image[1,:])/15)]
    right2 = [(whole_image[-bar_height:, -x-1].mean(),-x-1) 
              for x in range(len(whole_image[1,:])/15)]

    top1 = [(whole_image[x, :bar_height].mean(),x) 
            for x in range(len(whole_image[1,:])/15)]
    top2 = [(whole_image[x, -bar_height:].mean(),x) 
            for x in range(len(whole_image[1,:])/15)]

    bottom1 = [(whole_image[-x-1, :bar_height].mean(),-x-1) 
               for x in range(len(whole_image[1,:])/10)]
    bottom2 = [(whole_image[-x-1, -bar_height:].mean(),-x-1) 
               for x in range(len(whole_image[1,:])/10)]

    # reduce the list to the minimal values (darkest cells)
    left1 = [(x,i) for (x,i) in left1 if x < min(left1)[0]+5]
    left2 = [(x,i) for (x,i) in left2 if x < min(left2)[0]+5]

    right1 = [(x,i) for (x,i) in right1 if x < min(right1)[0]+5]
    right2 = [(x,i) for (x,i) in right2 if x < min(right2)[0]+5]

    top1 = [(x,i) for (x,i) in top1 if x < min(top1)[0]+10]
    top2 = [(x,i) for (x,i) in top2 if x < min(top2)[0]+10]

    bottom1 = [(x,i) for (x,i) in bottom1 if x < min(bottom1)[0]+10]
    bottom2 = [(x,i) for (x,i) in bottom2 if x < min(bottom2)[0]+10]
    

    # sort the tuples by index, keeping only the index
    left1 = sorted(left1, key = lambda x:x[1])
    left2 = sorted(left2, key = lambda x:x[1])
    right1 = sorted(right1, key = lambda x:x[1])
    right2 = sorted(right2, key = lambda x:x[1])
    top1 = sorted(top1, key = lambda x:x[1])
    top2 = sorted(top2, key = lambda x:x[1])
    bottom1 = sorted(bottom1, key = lambda x:x[1])
    bottom2 = sorted(bottom2, key = lambda x:x[1])


    # set the indeces
    left1 = left1[len(left1)/2][1] ; left2 = left2[len(left2)/2][1]
    right1 = right1[len(right1)/2][1] ; right2 = right2[len(right2)/2][1]
    top1 = top1[len(top1)/2][1] ; top2 = top2[len(top2)/2][1]
    bottom1 = bottom1[len(bottom1)/2][1] ; bottom2 = bottom2[len(bottom2)/2][1]

    top_diff = top2 - top1
    bottom_diff = bottom2 - bottom1
    left_diff = left2 - left1
    right_diff = right2 - right1
    
    # print 'top diff ' , top_diff, top1, top2
    # print 'bot diff ' , bottom_diff, bottom1, bottom2
    # print 'lef diff ' , left_diff, left1, left2
    # print 'rit diff ' , right_diff, right1, right2

    
    # print 'avg left to right diff : ', (top_diff - bottom_diff)/2
    # print 'avg top to bottom diff : ', (left_diff - right_diff)/2
    
    # first value corresponds to row
    # secnd value corresponds to col
    nw = (top1, left1)    ; ne = (top2, right1)
    sw = (bottom1, left2) ; se = (bottom2, right2)


    corners  = [nw, ne, se, sw]
    diffs = [left_diff, top_diff, right_diff, bottom_diff]
    
    # all values returned as they appear geometrically (from the west)
    # in clockwise manner
    return corners, diffs
    
def find_top(x):
    width = len(x[:,1])/4
    mid_row = len(x[:,1])/2
    while mid_row >= 0:
        if x[mid_row, width:-width].mean()>=248.: return mid_row 
        mid_row -=1

def find_bottom(x):
    width = len(x[:,1])/4
    mid_row = len(x[:,1])/2
    while mid_row <= len(x[:,1])-1:
        if x[mid_row, width:-width].mean()>=248.: return mid_row 
        mid_row +=1


def find_left(x):
    width = len(x[1,:])/4
    mid_col = len(x[1,:])/2
    while mid_col >= 0:
        if x[width:-width, mid_col].mean()>=248.: return mid_col 
        mid_col -=1

def find_right(x):
    width = len(x[1,:])/4
    mid_col = len(x[1,:])/2
    while mid_col <= len(x[1,:])-1:
        if x[width:-width, mid_col].mean()>=248.: return mid_col 
        mid_col +=1



def col_indeces(whole_img):
    
    corners, diff = edge_info(whole_img)
    
    top_diff = diff[1]
    
    nw_row_index = corners[0][0]
    nw_col_index = corners[0][1]
    
    row_length = len(whole_img[nw_row_index, :]) + corners[1][1] - corners[0][1]
    col_length = len(whole_img[nw_col_index, :]) + corners[3][0] - corners[0][0]
    
    jump = row_length/15

    curr_col_index = jump + nw_col_index

    Top_indeces = [nw_col_index]

    window_width = col_length/20
    
    while curr_col_index < row_length - jump/5:
        
        travel = curr_col_index - nw_col_index #distance traveled so far
        curr_row_index  = nw_row_index + top_diff*travel/row_length
        
        if whole_img[curr_row_index: curr_row_index + window_width
                     , curr_col_index].mean()< 50:
            Top_indeces.append(curr_col_index)
            curr_col_index += jump

        curr_col_index +=1
    
    Top_indeces.append(row_length + corners[0][1]) #make this the last index according to corners

    return Top_indeces



def row_indeces(whole_img):
    
    corners, diff = edge_info(whole_img)
    
    left_diff = diff[0]
    
    nw_row_index = corners[0][0]
    nw_col_index = corners[0][1]
    
    row_length = len(whole_img[nw_row_index, :]) + corners[1][1] - corners[0][1]
    col_length = len(whole_img[nw_col_index, :]) + corners[3][0] - corners[0][0]
    
    jump = col_length/15
    window_width = row_length/20

    Left_indeces = [nw_row_index]
    curr_row_index = jump + nw_row_index


    while curr_row_index < col_length - jump/5:
        
        travel = curr_row_index - nw_row_index #distance traveled so far
        curr_col_index  = nw_col_index + left_diff*travel/col_length
        
        if whole_img[curr_row_index, curr_col_index: curr_col_index + window_width].mean()< 50:
            Left_indeces.append(curr_row_index)
            curr_row_index += jump

        curr_row_index +=1
    
    Left_indeces.append(col_length + corners[0][0]) #make this the last index according to corners

    return Left_indeces


# def col_indeces(x):

#     jump = int(len(x[1,:])/10*.8)
#     Top_indeces = [0]
#     curr_index = jump

#     # find the column indeces from the top edge
#     while curr_index < len(x[1,:]) - len(x[1,:])/20:
#         if x[:len(x[:,1])/20,curr_index].mean() < 80:
#             Top_indeces.append(curr_index)
#             curr_index +=jump#len(x[1,:])/20
#         curr_index +=1

#     Top_indeces.append(len(x[1,:])-1)
#     Bottom_indeces = [0]
#     curr_index = jump

#     # find the column indeces from the bottom edge
#     while curr_index < len(x[1,:]) - len(x[1,:])/20:

#         if x[-len(x[:,1])/20:,curr_index].mean() < 80:
#             Bottom_indeces.append(curr_index)
#             curr_index +=jump#len(x[1,:])/20
#         curr_index +=1


#     Bottom_indeces.append(len(x[1,:])-1)


#     return (np.array(Top_indeces) + np.array(Bottom_indeces))/2


# def row_indeces(x): 
#     left_indeces = [0]
#     curr_index = len(x[:,1])/20

#     while curr_index < len(x[:,1]) - len(x[:,1])/20:
#         if x[curr_index,:len(x[1,:])/20].mean() < 80:
#             left_indeces.append(curr_index)
#             curr_index +=len(x[1,:])/20
#         curr_index +=1
#     left_indeces.append(len(x[:,1])-1)

    
#     right_indeces = [0]
#     curr_index = len(x[:,1])/20

#     while curr_index < len(x[:,1]) - len(x[:,1])/20:
#         if x[curr_index,:len(x[1,:])/20].mean() < 80:
#             right_indeces.append(curr_index)
#             curr_index +=len(x[1,:])/20
#         curr_index +=1
#     right_indeces.append(len(x[:,1])-1)

#     return (np.array(left_indeces) + np.array(right_indeces) )/2


def get_cell(x):
    left = find_left(x)
    right = find_right(x)
    top = find_top(x)
    bottom = find_bottom(x)
    # NOTE THAT UPPER LEFT HAND CORNER OF IMAGE IS (0,0)
    # THIS MEANS THAT top < bottom
    #                 left < right
    if top >= bottom or left >= right: 
        return None
    else:
        return x[top:bottom, left:right]
